<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Abandoned Orbitron</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet" />
    <style>
        html, body { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: 'Orbitron', sans-serif; touch-action: none; user-select: none; height: 100%; }
        canvas { display: block; position: fixed; inset: 0; z-index: 1; }
        #hud { position: fixed; top: 20px; left: 20px; color: #00ffcc; z-index: 100; font-size: 18px; pointer-events: none; text-shadow: 0 0 10px #00ffcc; }
        #crosshair { position: fixed; top: 50%; left: 50%; width: 18px; height: 18px; border: 2px solid #00ffcc; border-radius: 50%; transform: translate(-50%, -50%); z-index: 90; pointer-events: none; }
        #look-layer { position: fixed; inset: 0; z-index: 5; }
        #joystick-zone { position: fixed; bottom: 40px; left: 40px; width: 110px; height: 110px; border-radius: 50%; border: 2px solid rgba(0,255,204,0.3); background: rgba(255,255,255,0.05); z-index: 110; backdrop-filter: blur(5px); }
        #knob { position: absolute; top: 35px; left: 35px; width: 40px; height: 40px; background: #00ffcc; border-radius: 50%; box-shadow: 0 0 15px #00ffcc; }
        #shoot-btn { position: fixed; bottom: 50px; right: 50px; width: 90px; height: 90px; border-radius: 50%; border: 4px solid #ff0000; background: rgba(255,0,0,0.2); z-index: 110; touch-action: none; }
        #loading { position: fixed; inset: 0; background: #000; color: #00ffcc; display: flex; align-items: center; justify-content: center; z-index: 1000; }
    </style>
</head>
<body>

<div id="loading">INITIALIZING NEURAL LINK...</div>
<div id="hud">HP: 100 | KILLS: <span id="kills">0</span></div>
<div id="crosshair"></div>
<div id="look-layer"></div>
<div id="joystick-zone"><div id="knob"></div></div>
<div id="shoot-btn"></div>

<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
import * as THREE from 'three';

const CONFIG = { moveSpeed: 6, lookSense: 0.003, enemySpeed: 2.5 };
let kills = 0;

/* ENGINE SETUP */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020205);
scene.fog = new THREE.Fog(0x020205, 1, 25);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 1.6, 5);
camera.rotation.order = 'YXZ';

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* LIGHTING (Dark Building Style) */
const ambient = new THREE.AmbientLight(0x404040, 0.2); 
scene.add(ambient);

const flashlight = new THREE.SpotLight(0xffffff, 10, 20, Math.PI/6, 0.5);
camera.add(flashlight);
camera.add(flashlight.target);
flashlight.target.position.set(0, 0, -5);
scene.add(camera);

/* DARK ABANDONED BUILDING GENERATION */
const wallMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });
const floorMat = new THREE.MeshStandardMaterial({ color: 0x050505 });

for(let i = -5; i < 5; i++) {
    for(let j = -5; j < 5; j++) {
        // Floor & Ceiling
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), floorMat);
        floor.rotation.x = -Math.PI/2;
        floor.position.set(i*10, 0, j*10);
        scene.add(floor);

        const ceil = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), wallMat);
        ceil.rotation.x = Math.PI/2;
        ceil.position.set(i*10, 4, j*10);
        scene.add(ceil);

        // Random Pillars/Walls
        if(Math.random() > 0.8) {
            const pillar = new THREE.Mesh(new THREE.BoxGeometry(2, 4, 2), wallMat);
            pillar.position.set(i*10, 2, j*10);
            scene.add(pillar);
        }
    }
}

/* WEAPON */
const weaponGroup = new THREE.Group();
const body = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.8), new THREE.MeshStandardMaterial({color:0x222222}));
const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.4), new THREE.MeshStandardMaterial({color:0x00ffcc, emissive: 0x00ffcc}));
barrel.rotation.x = Math.PI/2;
barrel.position.z = -0.5;
weaponGroup.add(body, barrel);
weaponGroup.position.set(0.4, -0.4, -0.6);
camera.add(weaponGroup);

/* ENEMIES */
const enemies = [];
function spawnEnemy() {
    const geo = new THREE.IcosahedronGeometry(0.6, 0);
    const mat = new THREE.MeshStandardMaterial({ color: 0xff0000, wireframe: true, emissive: 0xff0000 });
    const enemy = new THREE.Mesh(geo, mat);
    enemy.position.set((Math.random()-0.5)*40, 1, (Math.random()-0.5)*40);
    enemy.userData = { hp: 100 };
    scene.add(enemy);
    enemies.push(enemy);
}
for(let i=0; i<6; i++) spawnEnemy();

/* INPUT LOGIC */
let moveData = { x: 0, y: 0 };
let lastTouch = { x: 0, y: 0 };
const clock = new THREE.Clock();

// Joystick
const joystick = document.getElementById('joystick-zone');
const knob = document.getElementById('knob');

joystick.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const rect = joystick.getBoundingClientRect();
    const t = e.touches[0];
    const dx = t.clientX - (rect.left + 55);
    const dy = t.clientY - (rect.top + 55);
    const dist = Math.min(Math.hypot(dx, dy), 40);
    const angle = Math.atan2(dy, dx);
    moveData.x = Math.cos(angle) * (dist/40);
    moveData.y = Math.sin(angle) * (dist/40);
    knob.style.transform = `translate(${moveData.x*35}px, ${moveData.y*35}px)`;
});

joystick.addEventListener('touchend', () => {
    moveData = { x: 0, y: 0 };
    knob.style.transform = 'translate(0,0)';
});

// Look Layer (Right side of screen)
const lookLayer = document.getElementById('look-layer');
lookLayer.addEventListener('touchmove', (e) => {
    const t = Array.from(e.touches).find(touch => touch.clientX > window.innerWidth / 2);
    if(!t) return;
    if(lastTouch.x !== 0) {
        camera.rotation.y -= (t.clientX - lastTouch.x) * CONFIG.lookSense;
        camera.rotation.x -= (t.clientY - lastTouch.y) * CONFIG.lookSense;
        camera.rotation.x = Math.max(-1.4, Math.min(1.4, camera.rotation.x));
    }
    lastTouch.x = t.clientX;
    lastTouch.y = t.clientY;
});
lookLayer.addEventListener('touchend', () => lastTouch = { x: 0, y: 0 });

// Shooting
const raycaster = new THREE.Raycaster();
document.getElementById('shoot-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    // Visual Recoil
    weaponGroup.position.z += 0.1;
    
    raycaster.setFromCamera({x:0, y:0}, camera);
    const hits = raycaster.intersectObjects(enemies);
    if(hits.length > 0) {
        const target = hits[0].object;
        scene.remove(target);
        enemies.splice(enemies.indexOf(target), 1);
        kills++;
        document.getElementById('kills').innerText = kills;
        setTimeout(spawnEnemy, 2000);
    }
});

/* GAME LOOP */
function animate() {
    const delta = clock.getDelta();
    requestAnimationFrame(animate);

    // Movement
    const dirF = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    const dirR = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
    dirF.y = 0; dirR.y = 0;
    camera.position.addScaledVector(dirF.normalize(), -moveData.y * CONFIG.moveSpeed * delta);
    camera.position.addScaledVector(dirR.normalize(), moveData.x * CONFIG.moveSpeed * delta);

    // Enemy AI & Gun Sway
    enemies.forEach(en => {
        en.position.lerp(camera.position, 0.01);
        en.rotation.y += 0.05;
    });
    weaponGroup.position.z = THREE.MathUtils.lerp(weaponGroup.position.z, -0.6, 0.1);

    renderer.render(scene, camera);
}

document.getElementById('loading').style.display = 'none';
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
