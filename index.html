<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mobile Zombie FPS</title>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
    body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; touch-action: none; }
    
    /* GAME UI LAYERS */
    #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
    #crosshair { 
        position: absolute; top: 50%; left: 50%; width: 15px; height: 15px; 
        border: 2px solid rgba(0, 255, 0, 0.8); border-radius: 50%; 
        transform: translate(-50%, -50%);
    }
    #hud { 
        position: absolute; top: 10px; left: 10px; color: #0f0; font-size: 18px; font-weight: bold; 
        text-shadow: 1px 1px 0 #000;
    }
    #loading { position: absolute; top: 45%; width: 100%; text-align: center; color: yellow; }

    /* --- MOBILE CONTROLS --- */
    
    /* 1. WALK JOYSTICK (Left) */
    #joystick-zone {
        position: absolute; bottom: 50px; left: 50px; width: 120px; height: 120px;
        background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255,255,255,0.3);
        border-radius: 50%; pointer-events: auto; touch-action: none;
    }
    #joystick-knob {
        position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
        background: rgba(0, 255, 0, 0.5); border-radius: 50%;
        transform: translate(-50%, -50%); pointer-events: none;
    }

    /* 2. SHOOT BUTTON (Right) */
    #shoot-btn {
        position: absolute; bottom: 60px; right: 40px; width: 80px; height: 80px;
        background: rgba(255, 0, 0, 0.5); border: 4px solid rgba(255, 0, 0, 0.8);
        border-radius: 50%; pointer-events: auto; display: flex;
        justify-content: center; align-items: center; color: white; font-weight: bold;
        user-select: none;
    }
    #shoot-btn:active { background: rgba(255, 0, 0, 0.9); transform: scale(0.95); }

    /* 3. LOOK AREA (The rest of the screen) */
    #touch-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        z-index: 1; /* Below buttons, above canvas */
    }

</style>
</head>
<body>

<div id="touch-layer"></div> <div id="joystick-zone"><div id="joystick-knob"></div></div>
<div id="shoot-btn">FIRE</div>

<div id="loading">LOADING ASSETS...</div>
<div id="ui-layer">
    <div id="crosshair"></div>
    <div id="hud">
        <div>HP: <span id="hp">100</span> | WAVE: <span id="wave">1</span></div>
        <div>ENEMIES: <span id="enemy-count">0</span></div>
    </div>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

// --- CONFIGURATION ---
const SETTINGS = {
    walkSpeed: 8.0,
    lookSensitivity: 0.004,
    enemySpeed: 4.0
};

// --- GLOBALS ---
let camera, scene, renderer;
let loadedWeaponModel, loadedZombieModel;
const projectiles = []; // Using visible bullets for better mobile feedback
const enemies = [];
const velocity = new THREE.Vector3(); // Player movement vector

// Game State
const gameState = {
    hp: 100,
    wave: 1,
    enemiesAlive: 0,
    gunMesh: null
};

// --- TOUCH STATE ---
const input = {
    moveX: 0, // Joystick Left/Right
    moveY: 0, // Joystick Up/Down
    isShooting: false
};

init();
animate();

function init() {
    // 1. Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    scene.fog = new THREE.FogExp2(0x111111, 0.04);

    // 2. Camera
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.6, 5);
    camera.rotation.order = 'YXZ'; // Important for FPS look

    // 3. Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
    document.body.appendChild(renderer.domElement);

    // 4. Lights
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    scene.add(hemiLight);
    
    // Flashlight
    const camLight = new THREE.PointLight(0xffffff, 0.8, 20);
    camera.add(camLight);
    scene.add(camera);

    // 5. Environment (Floor)
    const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x222222);
    scene.add(gridHelper);
    const floorGeo = new THREE.PlaneGeometry(100, 100);
    const floorMat = new THREE.MeshBasicMaterial({ color: 0x0a0a0a });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // 6. Load Assets
    const loader = new GLTFLoader();
    
    // Load Gun
    loader.load('gun.glb', (gltf) => {
        loadedWeaponModel = gltf.scene;
        loadedWeaponModel.scale.set(1, 1, 1); // ADJUST SIZE HERE
        loadedWeaponModel.rotation.y = Math.PI; // ADJUST ROTATION HERE
        setupWeapon(loadedWeaponModel);
        document.getElementById('loading').style.display = 'none';
    }, undefined, () => setupWeapon(null)); // Fallback

    // Load Zombie
    loader.load('zombie.glb', (gltf) => {
        loadedZombieModel = gltf.scene;
    });

    // 7. SETUP TOUCH CONTROLS
    setupMobileControls();

    // 8. Start Game
    startWave();
}

function setupWeapon(model) {
    if (gameState.gunMesh) camera.remove(gameState.gunMesh);
    if (model) {
        gameState.gunMesh = model;
        gameState.gunMesh.position.set(0.3, -0.4, -0.8); // Adjust position
    } else {
        // Fallback Box
        const geo = new THREE.BoxGeometry(0.2, 0.2, 1);
        const mat = new THREE.MeshStandardMaterial({ color: 0x888888 });
        gameState.gunMesh = new THREE.Mesh(geo, mat);
        gameState.gunMesh.position.set(0.3, -0.3, -0.5);
    }
    camera.add(gameState.gunMesh);
}

// --- MOBILE INPUT LOGIC ---
function setupMobileControls() {
    const joystickZone = document.getElementById('joystick-zone');
    const joystickKnob = document.getElementById('joystick-knob');
    const touchLayer = document.getElementById('touch-layer');
    const shootBtn = document.getElementById('shoot-btn');

    // 1. JOYSTICK (Walking)
    let joystickCenter = { x: 0, y: 0 };
    
    joystickZone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const rect = joystickZone.getBoundingClientRect();
        joystickCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
        updateJoystick(e.touches[0]);
    }, {passive: false});

    joystickZone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        updateJoystick(e.touches[0]);
    }, {passive: false});

    joystickZone.addEventListener('touchend', (e) => {
        e.preventDefault();
        input.moveX = 0;
        input.moveY = 0;
        joystickKnob.style.transform = `translate(-50%, -50%)`;
    });

    function updateJoystick(touch) {
        const maxDist = 40; // Max visual movement of knob
        let dx = touch.clientX - joystickCenter.x;
        let dy = touch.clientY - joystickCenter.y;
        
        // Calculate Distance
        const distance = Math.min(Math.sqrt(dx*dx + dy*dy), maxDist);
        const angle = Math.atan2(dy, dx);
        
        // Visual Update
        const knobX = Math.cos(angle) * distance;
        const knobY = Math.sin(angle) * distance;
        joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;

        // Logic Output (-1 to 1)
        input.moveX = knobX / maxDist;
        input.moveY = knobY / maxDist;
    }

    // 2. SWIPE (Looking)
    let prevTouchX = 0;
    let prevTouchY = 0;

    touchLayer.addEventListener('touchstart', (e) => {
        prevTouchX = e.touches[0].clientX;
        prevTouchY = e.touches[0].clientY;
    });

    touchLayer.addEventListener('touchmove', (e) => {
        const touch = e.touches[0];
        const dx = touch.clientX - prevTouchX;
        const dy = touch.clientY - prevTouchY;

        // Rotate Camera (Yaw and Pitch)
        camera.rotation.y -= dx * SETTINGS.lookSensitivity;
        camera.rotation.x -= dy * SETTINGS.lookSensitivity;
        
        // Clamp Up/Down look so you don't break your neck
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));

        prevTouchX = touch.clientX;
        prevTouchY = touch.clientY;
    });

    // 3. SHOOT BUTTON
    shootBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        shoot();
    });
}

function startWave() {
    gameState.enemiesAlive = 5 + gameState.wave;
    document.getElementById('enemy-count').innerText = gameState.enemiesAlive;
    document.getElementById('wave').innerText = gameState.wave;
    for(let i=0; i<gameState.enemiesAlive; i++) spawnEnemy();
}

function spawnEnemy() {
    let enemy;
    if (loadedZombieModel) {
        enemy = loadedZombieModel.clone();
        enemy.scale.set(1,1,1); // Adjust Zombie Scale
    } else {
        const geo = new THREE.BoxGeometry(1, 2, 1);
        const mat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        enemy = new THREE.Mesh(geo, mat);
    }

    const angle = Math.random() * Math.PI * 2;
    const rad = 20 + Math.random() * 20;
    enemy.position.set(Math.cos(angle) * rad, 0, Math.sin(angle) * rad);
    
    enemy.userData = { hp: 30 };
    scene.add(enemy);
    enemies.push(enemy);
}

function shoot() {
    // Visual Recoil
    if(gameState.gunMesh) {
        gameState.gunMesh.position.z += 0.2;
        setTimeout(()=> { if(gameState.gunMesh) gameState.gunMesh.position.z -= 0.2 }, 50);
    }

    // Raycast Shooting
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
    const intersects = raycaster.intersectObjects(enemies, true);

    if (intersects.length > 0) {
        let target = intersects[0].object;
        while(target.parent && target.parent !== scene && !enemies.includes(target)) {
            target = target.parent;
        }

        if (enemies.includes(target)) {
            target.userData.hp -= 15;
            
            // Flash red
            target.traverse((c) => {
                if(c.isMesh) {
                    c.material.emissive = new THREE.Color(0xff0000);
                    setTimeout(()=> c.material.emissive = new THREE.Color(0x000000), 100);
                }
            });

            if (target.userData.hp <= 0) {
                scene.remove(target);
                enemies.splice(enemies.indexOf(target), 1);
                gameState.enemiesAlive--;
                document.getElementById('enemy-count').innerText = gameState.enemiesAlive;
                
                if(gameState.enemiesAlive <= 0) {
                    gameState.wave++;
                    setTimeout(startWave, 2000);
                }
            }
        }
    }
}

function animate() {
    requestAnimationFrame(animate);
    
    // 1. Move Player
    // Calculate forward/right vectors based on where camera is looking
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
    
    // Ignore Y (flying)
    forward.y = 0; forward.normalize();
    right.y = 0; right.normalize();

    // Apply Joystick Input
    const speed = SETTINGS.walkSpeed * 0.1;
    camera.position.addScaledVector(forward, -input.moveY * speed);
    camera.position.addScaledVector(right, input.moveX * speed);

    // Keep on floor
    camera.position.y = 1.6;

    // 2. Update Enemies
    enemies.forEach(enemy => {
        const dir = new THREE.Vector3().subVectors(camera.position, enemy.position);
        dir.y = 0; dir.normalize();
        
        enemy.position.addScaledVector(dir, SETTINGS.enemySpeed * 0.01);
        enemy.lookAt(camera.position.x, enemy.position.y, camera.position.z);

        if(enemy.position.distanceTo(camera.position) < 1.0) {
            gameState.hp -= 0.5;
            document.getElementById('hp').innerText = Math.floor(gameState.hp);
            if(gameState.hp <= 0) {
                alert("GAME OVER");
                location.reload();
            }
        }
    });

    renderer.render(scene, camera);
}

// Handle window resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
