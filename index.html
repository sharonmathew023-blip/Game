<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Orbitron Strike: Final Fix</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Orbitron', sans-serif; touch-action: none; user-select: none; }
        
        /* UI ELEMENTS */
        #hud { position: fixed; top: 20px; left: 20px; color: #00ffcc; z-index: 100; font-size: 16px; pointer-events: none; background: rgba(0,0,0,0.4); padding: 10px; border-left: 3px solid #00ffcc; }
        #crosshair { position: fixed; top: 50%; left: 50%; width: 14px; height: 14px; border: 2px solid #00ffcc; border-radius: 50%; transform: translate(-50%, -50%); z-index: 90; pointer-events: none; }
        #loading { position: fixed; inset: 0; background: #000; color: #ffff00; display: flex; align-items: center; justify-content: center; z-index: 1000; font-size: 18px; }

        /* CONTROLS - Fixed Layering */
        #joystick-zone { position: fixed; bottom: 40px; left: 40px; width: 100px; height: 100px; background: rgba(255,255,255,0.1); border-radius: 50%; z-index: 110; touch-action: none; }
        #knob { position: absolute; top: 30px; left: 30px; width: 40px; height: 40px; background: #00ffcc; border-radius: 50%; box-shadow: 0 0 15px #00ffcc; pointer-events: none; }
        
        #shoot-btn { position: fixed; bottom: 50px; right: 50px; width: 90px; height: 90px; background: rgba(255,0,0,0.2); border: 4px solid #ff0000; border-radius: 50%; z-index: 110; box-shadow: 0 0 20px rgba(255,0,0,0.5); }
        #look-layer { position: fixed; inset: 0; z-index: 10; pointer-events: auto; }
    </style>
</head>
<body>

    <div id="loading">SYNCING NEURAL LINK...</div>
    <div id="hud">HP: <span id="hp">100</span> | KILLS: <span id="kills">0</span></div>
    <div id="crosshair"></div>
    <div id="look-layer"></div>
    <div id="joystick-zone"><div id="knob"></div></div>
    <div id="shoot-btn"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let camera, scene, renderer, gunGroup, muzzleLight;
        const enemies = [];
        const input = { moveX: 0, moveY: 0 };
        const loader = new GLTFLoader();

        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.Fog(0x050505, 1, 35);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ';
            camera.position.set(0, 1.6, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // LIGHTING
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            muzzleLight = new THREE.PointLight(0xffaa00, 0, 10);
            camera.add(muzzleLight);
            scene.add(camera);

            // GROUND GRID
            const grid = new THREE.GridHelper(200, 50, 0x00ffcc, 0x222222);
            scene.add(grid);

            // GUN SETUP
            gunGroup = new THREE.Group();
            camera.add(gunGroup);
            
            // Backup Gun (In case GLB fails)
            const backupGun = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.6), new THREE.MeshStandardMaterial({color: 0x444444}));
            backupGun.position.set(0.3, -0.3, -0.6);
            gunGroup.add(backupGun);

            // Try loading model
            loader.load('assets/models/gun.glb', (gltf) => {
                gunGroup.remove(backupGun);
                const model = gltf.scene;
                model.position.set(0.3, -0.4, -0.5);
                model.scale.set(0.4, 0.4, 0.4);
                gunGroup.add(model);
            });

            setupControls();
            spawnWave();
            animate();
            
            // Remove loading screen after 3 seconds
            setTimeout(() => { document.getElementById('loading').style.display = 'none'; }, 3000);
        }

        function setupControls() {
            const joystick = document.getElementById('joystick-zone');
            const knob = document.getElementById('knob');

            const move = (t) => {
                const rect = joystick.getBoundingClientRect();
                const x = t.clientX - rect.left - 50;
                const y = t.clientY - rect.top - 50;
                const dist = Math.min(Math.sqrt(x*x + y*y), 40);
                const angle = Math.atan2(y, x);
                input.moveX = (Math.cos(angle) * dist) / 40;
                input.moveY = (Math.sin(angle) * dist) / 40;
                knob.style.transform = `translate(${Math.cos(angle)*dist - 20}px, ${Math.sin(angle)*dist - 20}px)`;
            };

            joystick.addEventListener('touchstart', e => move(e.touches[0]));
            joystick.addEventListener('touchmove', e => move(e.touches[0]));
            joystick.addEventListener('touchend', () => { input.moveX = 0; input.moveY = 0; knob.style.transform = 'translate(-50%,-50%)'; });

            let px, py;
            document.getElementById('look-layer').addEventListener('touchstart', e => { px = e.touches[0].clientX; py = e.touches[0].clientY; });
            document.getElementById('look-layer').addEventListener('touchmove', e => {
                camera.rotation.y -= (e.touches[0].clientX - px) * 0.006;
                camera.rotation.x -= (e.touches[0].clientY - py) * 0.006;
                camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
                px = e.touches[0].clientX; py = e.touches[0].clientY;
            });

            document.getElementById('shoot-btn').addEventListener('touchstart', e => { e.preventDefault(); shoot(); });
        }

        function spawnWave() {
            for(let i=0; i<6; i++) {
                const z = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.8, 0.8), new THREE.MeshStandardMaterial({color: 0x8b0000}));
                const angle = Math.random() * Math.PI * 2;
                z.position.set(Math.cos(angle)*20, 0.9, Math.sin(angle)*20);
                z.userData = { hp: 30, speed: 0.03 + Math.random()*0.02 };
                scene.add(z);
                enemies.push(z);
            }
        }

        function shoot() {
            muzzleLight.intensity = 15;
            setTimeout(() => muzzleLight.intensity = 0, 50);
            gunGroup.position.z += 0.1;
            setTimeout(() => gunGroup.position.z -= 0.1, 50);

            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = ray.intersectObjects(enemies);
            if(hits.length > 0) {
                const hit = hits[0].object;
                hit.userData.hp -= 10;
                if(hit.userData.hp <= 0) {
                    scene.remove(hit);
                    enemies.splice(enemies.indexOf(hit), 1);
                    document.getElementById('kills').innerText = parseInt(document.getElementById('kills').innerText) + 1;
                    if(enemies.length === 0) spawnWave();
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
            const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
            forward.y = 0; right.y = 0;
            camera.position.addScaledVector(forward, -input.moveY * 0.14);
            camera.position.addScaledVector(right, input.moveX * 0.14);

            enemies.forEach(z => {
                const dir = new THREE.Vector3().subVectors(camera.position, z.position).normalize();
                z.position.x += dir.x * z.userData.speed;
                z.position.z += dir.z * z.userData.speed;
                z.lookAt(camera.position.x, 0.9, camera.position.z);
                if(z.position.distanceTo(camera.position) < 1.2) {
                    let hp = parseInt(document.getElementById('hp').innerText) - 1;
                    document.getElementById('hp').innerText = Math.max(0, hp);
                    if(hp <= 0) location.reload();
                }
            });
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
