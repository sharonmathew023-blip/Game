<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Zombie Survival FPS</title>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
    #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; user-select: none; }
    
    /* HUD */
    #hud { position: absolute; bottom: 20px; left: 20px; color: #0f0; font-size: 24px; text-shadow: 2px 2px #000; }
    #crosshair { 
        position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; 
        border: 2px solid rgba(0, 255, 0, 0.7); border-radius: 50%; 
        transform: translate(-50%, -50%);
    }
    #damage-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: radial-gradient(circle, transparent 50%, red 150%);
        opacity: 0; transition: opacity 0.2s;
    }

    /* Start Screen */
    #blocker { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; pointer-events: auto; z-index: 999; }
    #instructions { color: white; text-align: center; cursor: pointer; }
    h1 { font-size: 40px; margin-bottom: 10px; color: #f00; text-transform: uppercase; }
</style>
</head>
<body>

<div id="damage-overlay"></div>
<div id="ui-layer">
    <div id="crosshair"></div>
    <div id="hud">
        <div>HEALTH: <span id="hp">100</span></div>
        <div>AMMO: <span id="ammo">30</span> / <span id="mag">âˆž</span></div>
        <div>WAVE: <span id="wave">1</span></div>
        <div>ENEMIES: <span id="enemy-count">0</span></div>
    </div>
</div>

<div id="blocker">
    <div id="instructions">
        <h1>SURVIVAL FPS</h1>
        <p>CLICK TO PLAY</p>
        <p>(W,A,S,D = Move | MOUSE = Look | CLICK = Shoot | R = Reload)</p>
    </div>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

// --- CONFIGURATION ---
const SETTINGS = {
    playerSpeed: 10.0,
    playerRunSpeed: 18.0,
    gravity: 30.0,
    jumpHeight: 15.0,
    enemySpeed: 6.0,
    enemyDmg: 10
};

// --- GLOBALS ---
let camera, scene, renderer, controls;
let raycaster;
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false, isRunning = false;
let prevTime = performance.now();
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();

// Game State
const gameState = {
    hp: 100,
    ammo: 30,
    maxAmmo: 30,
    isReloading: false,
    wave: 1,
    enemiesAlive: 0,
    score: 0
};

const enemies = [];
const bullets = []; // Only for visual tracers

// DOM Elements
const hpEl = document.getElementById('hp');
const ammoEl = document.getElementById('ammo');
const waveEl = document.getElementById('wave');
const enemyCountEl = document.getElementById('enemy-count');
const damageOverlay = document.getElementById('damage-overlay');

init();
animate();

function init() {
    // 1. Scene Setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    scene.fog = new THREE.Fog(0x111111, 0, 80); // Atmosphere

    // 2. Camera & Lighting
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    const light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
    light.position.set(0.5, 1, 0.75);
    scene.add(light);
    
    // Flashlight
    const spotLight = new THREE.SpotLight(0xffffff, 1);
    spotLight.position.set(0, 0, 0); // Attached to camera later
    spotLight.angle = Math.PI / 6;
    spotLight.penumbra = 1;
    spotLight.decay = 2;
    spotLight.distance = 50;
    camera.add(spotLight);
    spotLight.target.position.set(0, 0, -1);
    camera.add(spotLight.target);

    // 3. Controller (PointerLock)
    controls = new PointerLockControls(camera, document.body);
    const blocker = document.getElementById('blocker');
    const instructions = document.getElementById('instructions');

    instructions.addEventListener('click', function () {
        controls.lock();
    });

    controls.addEventListener('lock', function () {
        blocker.style.display = 'none';
    });

    controls.addEventListener('unlock', function () {
        blocker.style.display = 'flex';
    });

    scene.add(controls.getObject());

    // 4. Weapon (Placeholder Gun)
    const gunGeo = new THREE.BoxGeometry(0.5, 0.5, 2);
    const gunMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
    const gun = new THREE.Mesh(gunGeo, gunMat);
    gun.position.set(0.5, -0.5, -1); // Bottom right of screen
    camera.add(gun); // Attach to camera so it moves with view
    gameState.gunMesh = gun; // Store ref for recoil animation

    // 5. Environment (Map)
    // Floor
    const floorGeometry = new THREE.PlaneGeometry(200, 200);
    const floorMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x222222,
        roughness: 0.8 
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Obstacles
    const boxGeo = new THREE.BoxGeometry(5, 5, 5);
    const boxMat = new THREE.MeshStandardMaterial({ color: 0x553311 });
    for (let i = 0; i < 20; i++) {
        const box = new THREE.Mesh(boxGeo, boxMat);
        box.position.x = Math.floor(Math.random() * 20 - 10) * 8;
        box.position.z = Math.floor(Math.random() * 20 - 10) * 8;
        box.position.y = 2.5;
        scene.add(box);
    }

    // 6. Logic Hooks
    raycaster = new THREE.Raycaster();

    // Input Listeners
    const onKeyDown = function (event) {
        switch (event.code) {
            case 'ArrowUp': case 'KeyW': moveForward = true; break;
            case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
            case 'ArrowDown': case 'KeyS': moveBackward = true; break;
            case 'ArrowRight': case 'KeyD': moveRight = true; break;
            case 'Space': if (canJump === true) velocity.y += SETTINGS.jumpHeight; canJump = false; break;
            case 'ShiftLeft': isRunning = true; break;
            case 'KeyR': reload(); break;
        }
    };

    const onKeyUp = function (event) {
        switch (event.code) {
            case 'ArrowUp': case 'KeyW': moveForward = false; break;
            case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
            case 'ArrowDown': case 'KeyS': moveBackward = false; break;
            case 'ArrowRight': case 'KeyD': moveRight = false; break;
            case 'ShiftLeft': isRunning = false; break;
        }
    };

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    document.addEventListener('mousedown', shoot);

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    window.addEventListener('resize', onWindowResize);

    // Initial Wave
    startWave();
}

// --- CORE GAME MECHANICS ---

function startWave() {
    gameState.enemiesAlive = 5 + (gameState.wave * 2);
    enemyCountEl.innerText = gameState.enemiesAlive;
    waveEl.innerText = gameState.wave;
    
    for(let i=0; i < gameState.enemiesAlive; i++) {
        spawnEnemy();
    }
}

function spawnEnemy() {
    const geo = new THREE.BoxGeometry(1.5, 3, 1.5);
    const mat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
    const enemy = new THREE.Mesh(geo, mat);
    
    // Spawn random position away from player
    const angle = Math.random() * Math.PI * 2;
    const radius = 30 + Math.random() * 30;
    enemy.position.set(Math.cos(angle) * radius, 1.5, Math.sin(angle) * radius);
    
    // Enemy Properties
    enemy.userData = { 
        health: 30 + (gameState.wave * 5),
        speed: SETTINGS.enemySpeed * (0.8 + Math.random() * 0.4),
        type: 'zombie'
    };
    
    scene.add(enemy);
    enemies.push(enemy);
}

function shoot() {
    if (!controls.isLocked || gameState.ammo <= 0 || gameState.isReloading) {
        if(gameState.ammo <= 0) reload();
        return;
    }

    gameState.ammo--;
    ammoEl.innerText = gameState.ammo;

    // Visual Recoil
    gameState.gunMesh.position.z += 0.2;
    setTimeout(() => { gameState.gunMesh.position.z -= 0.2; }, 50);

    // Muzzle flash visual (simple yellow line)
    // Raycast Logic (Hitscan)
    raycaster.setFromCamera( new THREE.Vector2(0,0), camera ); // Center of screen
    const intersects = raycaster.intersectObjects(enemies);

    if (intersects.length > 0) {
        const hit = intersects[0];
        const target = hit.object;
        
        // Visual Hit Effect
        target.material.color.setHex(0xffffff); // Flash white
        setTimeout(() => target.material.color.setHex(0xff0000), 100);

        target.userData.health -= 15; // Weapon Damage
        
        if(target.userData.health <= 0) {
            killEnemy(target);
        }
    }
}

function reload() {
    if(gameState.isReloading || gameState.ammo === gameState.maxAmmo) return;
    gameState.isReloading = true;
    gameState.gunMesh.rotation.x = -0.5; // Visual reload tilt
    
    ammoEl.innerText = "REL...";
    
    setTimeout(() => {
        gameState.ammo = gameState.maxAmmo;
        gameState.isReloading = false;
        gameState.gunMesh.rotation.x = 0;
        ammoEl.innerText = gameState.ammo;
    }, 1500); // 1.5s reload time
}

function killEnemy(enemy) {
    scene.remove(enemy);
    const idx = enemies.indexOf(enemy);
    if(idx > -1) enemies.splice(idx, 1);
    
    gameState.score += 10;
    gameState.enemiesAlive--;
    enemyCountEl.innerText = gameState.enemiesAlive;

    if(enemies.length === 0) {
        gameState.wave++;
        setTimeout(startWave, 3000); // Wait 3s before next wave
    }
}

function takeDamage(amount) {
    gameState.hp -= amount;
    hpEl.innerText = Math.floor(gameState.hp);
    
    // Blood screen effect
    damageOverlay.style.opacity = 0.8;
    setTimeout(() => { damageOverlay.style.opacity = 0; }, 300);

    if(gameState.hp <= 0) {
        controls.unlock();
        alert("GAME OVER - Wave Reached: " + gameState.wave);
        location.reload();
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);

    const time = performance.now();
    
    if (controls.isLocked) {
        const delta = (time - prevTime) / 1000;

        // --- 1. PLAYER MOVEMENT ---
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        velocity.y -= 9.8 * 100.0 * delta; // Gravity

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        const currentSpeed = isRunning ? SETTINGS.playerRunSpeed : SETTINGS.playerSpeed;

        if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta * (currentSpeed/10);
        if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta * (currentSpeed/10);

        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);
        controls.getObject().position.y += (velocity.y * delta);

        if (controls.getObject().position.y < 1.5) {
            velocity.y = 0;
            controls.getObject().position.y = 1.5;
            canJump = true;
        }

        // --- 2. ENEMY AI ---
        const playerPos = controls.getObject().position;
        
        enemies.forEach(enemy => {
            // Move towards player
            const dx = playerPos.x - enemy.position.x;
            const dz = playerPos.z - enemy.position.z;
            const dist = Math.sqrt(dx*dx + dz*dz);
            
            if(dist > 1.0) {
                const speed = enemy.userData.speed * delta;
                enemy.position.x += (dx / dist) * speed;
                enemy.position.z += (dz / dist) * speed;
                enemy.lookAt(playerPos.x, 1.5, playerPos.z); // Face player
            } else {
                // Attack Player
                takeDamage(0.5); // Damage over time while touching
            }
        });
    }

    prevTime = time;
    renderer.render(scene, camera);
}
</script>
</body>
</html>
